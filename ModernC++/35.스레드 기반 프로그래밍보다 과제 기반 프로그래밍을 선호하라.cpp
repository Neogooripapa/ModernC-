#include <iostream>
#include <memory>
#include <vector>
#include <set>
#include <chrono>
#include <array>
#include <functional>
#include <thread>
#include <future>
using namespace std;

int doAsyncWork()
{
	return 0;
}

void foo()
{
	std::thread t(doAsyncWork);

	//과제기반 프로그래밍.
	auto fut = std::async(doAsyncWork);

	//이 예제에서 doAsyncWork는 반환값을 돌려주는데, 
	//doAsyncWork를 호출하는 코드가 그 반환값에 관심이 있을 것이라고 가정하는 것이 합리적이다.
	//스레드 기반 호출에서는 그 반환값에 접근할 방법이 없다. 
	//그러나 과제 기반 접근방식에서는 간단하게 접근할 수 있다.

	auto t = fut.get(); //이 함수로 접근가능. 함수가 예외를 방출하면 get을 통해서 예외에 접근할 수도 있다.
						//스레드 기반 접근방식에서는, doAsyncWork가 예외를 던지면 프로그램이 죽는다.(std::terminate호출을 통해서)


	//동시적 C++ 소프트웨어에서 '스레드'라는 용어는 3가지 의미로 쓰인다.
	//1.실제 계산을 수행하는 스레드를 뜻하는 하드웨어 스레드, 현세대의 컴퓨터 아키텍처는 cpu코어당 하나 이상의 하드웨어 스레드를 제공한다.
	//2.운영체제가 하드웨어 스레드들에서 실행되는 모든 프로세서의 일정을 관리하는데 사용하는 소프트웨어 스레드.
	//  OS스레드나 시스템 스레드라고도 한다. 하드웨어 스레드보단 많은 소프트웨어 스레드를 생성할 수 있다.
	//3.C++표준 라이브러리 std::thread. 하나의 C++프로세스 안에서 std::thread 객체는 바탕 소프트웨어 스레드에 대한 핸들로 작용한다.
	//  std::thread객체가 널 핸들을 나타내기도한다. 실행함수가 없는 경우 등등.
}


int doAsyncWork2() noexcept
{
	return 0;
}

void foo2()
{
	//소프트웨어 스레드는 제한된 자원이다. 시스템이 제공할 수 있는 것보다 많은 소프트웨어 스레드를 생성하려 하면
	//std::system_error 예외가 발생한다.
	//이는 스레드에서 실행하고자 하는 함수가 예외를 던질 수 없는 경우에도 마찬가지이다. 

	std::thread t(doAsyncWork2); //사용 가능한 스레드가 없으면 예외가 발생한다.

	//위 예외를 극복하려면 일부 소프트웨어 스레드가 완료되길 기다렸다가 std::thread를 새로 생성하는 방법이 있다.
	//그런데 기존 스레드 들이 doAsyncWork2가 수행해야 하는 어떤 동작(결과, 조건변수 통지)을 기다리고 있을 수 도 있다.
	//가용 스레드가 모자라지 않는다고 해도, 과다구독(소프투웨어 스레드가 하드웨어 스레드보다 많은 상황)이 일어날 수 있다.
	//이때 context switch가 일어나고 스레드 관리 부담이 증가한다.

	//위와 같은 문제들을 다른 누군가에게 떠넘긴다면 편해질 것이다.
	auto fut = std::async(doAsyncWork); //스레드 관리부담을 표준 라이브러리 구현자들에게 떠넘긴다.

	//이렇게 하면, 가용 스레드 부족 때문에 예외를 받을 가능성이 크게 줄어든다. 이 호출은 예외를 방출할 가능성이 거의 없기 때문이다.

	//왜그러냐면 std::async가 새 소프트웨어 스레드를 생성하지 않을 수도 있기 때문이다.
	//대신 std::async는 지정된 함수를 doAsyncWork의 결과가 필요한 스레드(fut에대해 get이나 wait를 호출하는 스레드)에서
	//실행 하라고 스케줄러에게 요청할 수 있으며, 합리적인 스케줄러는 시스템이 과다구독되었거나 스레드가 부족한 상황에서 그러한 자유의 장점을 취한다.

	//std::async에서도 GUI스레드의 반응성이 여전히 문제가 될 수 있다. 스케줄러로서는 독자의 스레드 중 반응성이 좋아야 하는 스레를 모른다.
	//그런경우에는 std::launch::async라는 시동방침을 std::async에게 넘겨주는것이 좋다.
	//그러면 실행하고자 하는 함수가 실제로 현재 스레드와는 다른 스레드에서 실행된다.

	//std::thread를 직접 다루는 방식으로 프로그래밍한다면 스레드고갈, 과다구독, 부하 불균형화를 처리하는 부담을 독자 스스로 짊어져야한다.

	//스레드 기반 프로그래밍에 비해 과제 기반 프로그래밍에는 독자가 스레드들을 일일이 관리해야 하는 수고로움이 없다.
	//또한, 과제기반 설계는 비동기적으로 실행된 함수의 결과를 자연스럽게 조화할 수 있는 수단(즉, 반환값 또는 예외)도 제공한다.

	//그렇지만 스레드를 직접 다루는게 적합한 경우도 존재한다.
	//1.바탕 스레드 적용 라이브러리의 API에 접근해야 하는 경우 
	//  C++동시성 API는 저수준 플랫폼 고유 API를 통해서 구현된다(windows스레드 라이브러리 등등) 이런 라이브러리 들은 C++보다 풍부한 기능을 제공한다.
	//  (C++스레드 우선순위나 친화도 같은 개념이 없다) 바탕 스레드 적용 라이브러리의 API에 접근할 수 있도록 std::thread객체는 흔히 native_handle이라는
	//  멤버 함수를 제공한다. 하지만 std::future에는 이에 해당하는 기능이 없다.
	//2.응용 프로그램의 스레드 사용량을 최적화해야 하는, 그리고 할수 있어야 하는 경우.
	//  하드웨어 특성이 미리 정해진 컴퓨터에서 유일하게 돌아가는 프로세스로 실행될 서버 소프트웨어를 개발할때.
	//3.C++동시성 API가 제공하는 것 이상의 스레드 적용 기술을 구현해야 하는 경우
	//  특정 플랫폼을 위해 스레드 풀을 직접 구현해야 하는 경우가 있다.
}
void main()
{
}