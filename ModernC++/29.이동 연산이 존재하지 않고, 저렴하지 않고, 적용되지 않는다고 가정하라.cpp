#include <iostream>
#include <memory>
#include <vector>
#include <set>
#include <chrono>
#include <array>
using namespace std;

class Widget
{
};

int main()
{
	std::vector<Widget> vw1;
	//vw1에 자료를 채운다.

	//이 이동은 상수 시간으로 실행된다. 오직 vw1과vw2의 포인터들만 수정된다.
	auto vw2 = std::move(vw1); //vw1 -> Widget들 => vw1 = null => vw2 = Widget들 (포인터로 대상을 가리키때문에 이게 가능하다)

	//그런데 std::array객체에는 그런 포인터가 없다.
	//std::array의 내용은 std::array 객체 자체에 직접 저장되기 때문이다.
	std::array<Widget, 10000> aw1;

	//aw1에 자료를 채운다.

	//이 이동은 선형 시간이 소요된다.
	//일일이 이동해야 하기때문에 복사와 별반 다르지 않다.
	auto aw2 = std::move(aw1);

	//std::string은 상수 시간 이동과 선형 시간 복사를 제공한다.
	//이점을 생각하면 이동이 복사보다 빠를것같지만 그렇지 않은 경우가 있다.
	//작은 문자열 최적화를 사용하느 경우 (이를 테면 용량이 15자 이하인)을 std::string객체 안의 버퍼에 저장하고
	//힙에 할당한 저장소는 사용하지 않는다.


	//C++98코드를 C++11에서 컴파일해도 코드가 망가지지 않게 하기위해
	//이동 연산들이 예외를 던지지 않음이 확실한 경우에만 바탕 복사 연산들을 이동 연산들로 대체한다.
	//이 때문에 해당 복사 연산보다 효율적인 이동연산을 제공하는 형식이라고 해도, 그리고 코드의 특정 지점에서
	//일반적으로 이동연산이 적합하다고 해도, 해당 이동 연산이 noexcept로 선언되어 있지 않으면 
	//컴파일러는 여전히 복사 연산을 호출할 수 있다.

	//다음은 이동 의미론이 도움이 되지 않는 몇가지 시나리오 이다.
	//1.이동 연산이 없다. (이경우 이동 요청은 복사 요청이 된다)
	//2.이동이 더 빠르지 않다. (복사 연산보다 느린 경우)
	//3.이동을 사용할 수 없다. (예외를 방출하지 않아야 하는 문맥에서, 해당 연산이 noexcept로 선언되어 있지 않다)
	//4.객체가 왼갑이다. (오직 오른값만 이동 연산의 원본이 될 수 있는 경우도 있다)

	//형식들과 이동 의미론 지원 여부를 미리 알 수 있는 경우 위와같은 가정을 둘 필요가 없다.

	return 0;
}